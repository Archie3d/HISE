![](SNEX.png)

Version: 1.0 alpha

# Scriptnode Expression Language

The Scriptnode Expression Language (**SNEX**) is a simplified subset of the C language family and is used throughout scriptnode for customization behaviour.

- **fast**. The assembly code generated by the compiler should (more or less) match the performance of C++ compiled code. 
- **easy to use**. The syntax can be adapted within minutes for people who know C++ and / or Javascript.
- **safe** - it's impossible to crash the application. Every call that could lead to a access violation is wrapped into a safe check

It's intended use is fast execution of expressions for signal processing algorithms. Unlike the HiseScript language, which is interpreted, the scriptnode expressions are JIT compiled and run in almost native speed (several orders of magnitude above HiseScript performance). When the scriptnode graph is exported as Cpp code, the expressions will be then compiled by the standard compiler (which is why it needs to be a strict subset of C / C++).

The JIT compiler uses the awesome `asmjit` library to emit the assembly instructions. Currently supported are macOS / Windows / Linux (32bit / 64bit). iOS support is not possible due to the security restriction that prevents allocation of executable memory.

There are two places where it can be used: in the `core.jit` node, which allows creating fully customizable nodes and at the connection between parameters (or modulation sources) via the `Expression` property which can be used to convert the value send to the connection target.

## Getting started

The easiest way to get to know the language is to use the SNEX Playground which offers you a JIT compiler, a code editor with a predefined snippet and shows the assembly output that is fed directly to the CPU.

## Embedding the language

Embedding the language in a C++ project is pretty simple:

```cpp

// Create a global scope that contains global variables.
snex::jit::GlobalScope pool;

// Create a compiler that turns a String into a function pointer.
snex::jit::Compiler compiler(pool);

// The SNEX code to be parsed - Check the language reference below
juce::String code = "float member = 8.0f; float square(float input){ member = input; return input * input; }";

// Compiles and returns a object that contains the function code and slots for class variables.
if (auto obj = compiler.compileJitObject(code))
{
	// Returns a wrapper around the function with the given name
	auto f = obj["square"];

	// Returns a reference to the variable slot `member`
	auto ptr = obj.getVariablePtr("member");

	DBG(ptr->toFloat()); // 8.0f

	// call the function - the return type has to be passed in via template.
    // It checks that the function signature matches 
    // and the JIT function was compiled correctly.
	auto returnValue = f.call<float>(12.0f);
    
    
	DBG(returnValue); // 144.0f
	DBG(ptr->toFloat()); // 12.0f
}
else
{
    DBG(compiler.getErrorMessage());
}
```

## Language Reference

This is the complete language reference. Features that deviate from C / Cpp are **emphasized**

The **SNEX** syntax uses brackets for blocks and semicolons for statements. Comment lines start with `//`, multiline comments with `/** Comment */)`

```cpp

/** This is a 
    multiline comment
*/
{
	x; // a statement
}
```



You can define variables in any scope (function scope or global scope), however **there are no anonymous scopes**.

## Language structure

A valid SNEX code contains of definitions of variables and functions:

```cpp
// some variables
type a = something;
type b = somethingElse;
...

// function definitions
type functionName()
{
    //... function body
}
```

**There is no concept of classes or any other object oriented design principle.** The rationale behind this is that a SNEX compiled object is already a class.

## Variables

Variable names must be a valid identifier, and **definitions must initialise the value**:

```cpp
type variableName = initialValue;
```

You can also define constant values by prepending `const` to the definition:

```cpp
const type value = initialValue;
```

Doing so will speed up the compilation because it doesn't need to lookup the memory location.

## Functions


Function definitions have this syntax:

```cpp
ReturnType functionName(ArgumentType1 arg1, ArgumentType2 arg2)
{
   // body
}
```

Functions can be overloaded: despite having the same name, their argument amount and types can vary. However they can't differ only in the return type.

## Types

Unlike HiseScript, **SNEX** is strictly typed. **However there is a very limited set of available types**:

- `int` - Integer numbers
- `float` - single precision floating point numbers, marked with a trailing `f`: `2.012f`
- `double`- double precision floating point numbers
- `bool` - boolean values (just as intermediate type for expression results)
- `block` - a wrapper around a preallocated buffer of float numbers
- `event` - the HiseEvent

**There is no String type**. Conversion between the types is done via a C-style cast:

```cpp
// converts a float to an int
int x = (int)2.0f;
```

Type mismatches will be implicitely corrected by the compiler if possible (but it will produce a warning message so it's not recommended behaviour to just don't care about types).

## Variable visibility

**SNEX** variables are visible inside their scope (= `{...}` block) or parent scopes. The inner scope has the highest priority and override variable names is possible:

```
void test()
{
    float x = 25.0f;
	
	{
		float x = 90.0f;
		Console.print(x); // 90.0f;
	}
	
	Console.print(x); // 25.0f;
}
```

However, since this is a common pitfall for bugs, it will produce a compiler warning.

## Operators

### Binary Operations

The usual binary operators are available: 

```cpp
a + b; // Add
a - b; // Subtract
a * b; // Multiply
a / b; // Divide
a % b; // Modulo

a++; // post-increment (no pre increment support!)

!a; // Logical inversion
a == b; // equality
a != b; // inequality
a > b; // greater than
a >= b; // greater or equal
// ...

```

The rules of operator precedence are similar to every other programming language on the planet. You can use parenthesis to change the order of execution:

```cpp
(a + b) * c; // = a * c + b * c
```

Logical operators are short-circuited, which means that the second branch of a `&&` operator will not be evaluated if the first branch is false:

```cpp
int f1()
{
    Console.print(52.0f);
    return 0;
}

int f2()
{
    Console.print(12.0f);
    return 0;
}

void test()
{
	int c = f1() && f2() ? 2 : 1;
    Console.print(c);
}

// Will print 52 and 1 (f2 will not be executed)
```

### Assignment

Assigning a value to a variable is done via the `=` operator. Other assignment types are supported:

```cpp
int x = 12;
x += 3; // x == 15
x /= 3 // x == 5
```

You can access elements of a `block` via the `[]` operator:

```cpp
block b;
b[12] = 12.0f;
```

**There is an out-of-bounds check that prevents read access violations** if you use an invalid array index.

### Ternary Operator

There is no `if` statement branching in **SNEX**, however conditional execution can be achieved using the ternary operator:

```cpp
a ? b : c
```

The false branch will not be evaluated.

The rationale behind this is that in a inner loop of a DSP algorithm should not rely on heavy branching. If you however do so, you can workaround this by calling functions:

```cpp
void trueBranch()
{
    // some statements;
}

void falseBranch()
{
    // some statements;
}

void test(int input)
{
	input > 5 ? trueBranch() : falseBranch();
}

```

### Function calls

You can call other functions using this syntax: `functionCall(parameter1, parameter2);`Be aware that forward declaring is not supported so you can't call functions before defining them:

```cpp
void f1()
{
    f2(); // won't work
}

void f1()
{
    doSomething();
}

void f3()
{
    f1(); // now you can call it
}
```

### Return statement

Functions that have a return type need a return statement at the end of their function body:

```cpp
void f1()
{
    // Do something
    return; // this is optional
}

int f2()
{
	return 42; // must return a int
}

```


### API classes

There are a few inbuilt API classes that offer additional helper functions.

- the `Math` class which contains a set of mathematical functions
- the `Console` class for printing a value to the console
- the `Message` class which contains methods to operate on a HiseEvent.

The syntax for calling the API functions is the same as in HiseScript: `Api.function()`.

```cpp
float x = Math.sin(2.0f);
```

> The `Math` class contains overloaded functions for `double` and `float`, so be aware of implicit casts here.

